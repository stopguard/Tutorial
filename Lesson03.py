""""""
r"""
c = {a: b} - словарь, где а - неизменяемый объект являющийся ключом, а b - значение привязанное к ключу a

c.get(d, e=None) - возвращает значение ключа d в словаре c. В случае отсутствия ключа возвращает e не меняя словарь
c.setdefault(d, e=None) - возвращает значение ключа d в словаре c. 
                          В случае отсутствия ключа d возвращает e, добавив в словарь ключ d со значением e
c[d] = e - присваивает ключу d значение e.
           Если ключа d не существует - создает его со значением e
c.update(f) - добавляет в словарь c ключи и значения из словаря f
g = c.popitem() - возвращает последний ключ со значением из словаря c в переменную g в виде кортежа,
                  удалив их из словаря c
g = c.pop(d) - возвращает значение ключа d из словаря c в переменную g, удалив его из словаря c

для итерирования пары в циклах можно использовать метод .items()(аналогично функции ennumerate() в списках/кортежах):
for key, val in a.items():
    body

for value in a.values(): - итерируем только значения в словаре
for key in a.keys(): - итерируем только ключи в словаре

Функция:
def a(b, c, d):
    def block
    return r

def - для начала объявления именованной функции
a() - имя функции
(b, c, d) - переменные загружаемые в функцию.
return r - завершение функции и вывод объекта r

(lambda x, y: body)(a, b) -    лямбда функция которая возвращает результат вычисления body
                                    (как будто перед body стоит return) 
                                    переменные a и b передаются в эту функцию в качестве x и y

a(x, y, z) - вызов функции a с передачей в нее значений x, y, z которые внутри функции a будут называться b, c и d

a.strip(b = ' ') - очистка начала и конца строки от символов содержащихся в строке b.

callback - передача функции без скобок в качестве аргумента

filter(a, b) - возвращает иттератор последовательности из элементов последовательности b 
               отправка которых в функцию a возвращает True
               
map(a, b) - выполнение функции a (указывается без скобок) по отношению ко всем элементам последовательности b
            возвращает иттератор. Для print требуется распаковка либо преобразование в список/кортеж
            
for a in zip(list_a, list_b, list_c): - проход итератором одновременно по нескольким спискам - возвращает кортеж a
for a, b, c in zip(list_a, list_b, list_c): - кортеж можно распаковать в переменные
                                            - zip останавливается когда заканчиваются индексы кратчайшего контейнера

*map(a, b) - распаковка результата работы map

""" """ - комментирование. При использовании в следующей после объявления функции строке коммент добавляется в справку
          по нажатию на Ctrl
          
global a - позволяет изменять глобальную переменную в рамках функции
           функции видят только те переменные которые были объявлены до вызова функции

def a(*b): - передача любого количества переменных в функцию a с их записью в кортеж b

a(h='x')    - вызов функции передав аргументу h значение 'x'
def a(**b): - b принимает любое количество именованных аргументов не прописанных в a преобразовывая их в словарь
    print(b) # {'h': 'x'}

def a(b = c): - в случае вызова функции без указания аргумента b, ему будет присвоено значение c
всегда сначала пишем в функцию обычные аргументы, затем необязательные, затем уже * и **
* и ** аргументы принято именовать *args и **kvargs
распаковка списка - * перед списком
распаковка словаря - ** перед словарём

модуль random:
random.randrange(x, y, z) - случайное целое между x и y(не включая y) с шагом z
random.randint(x, y) - случайное целое между x и y
random.choice(a) - случайный элемент последовательности a
c = random.choices(a, k=b) - возвращает последовательность из b случайных элементов последовательности a
random.shuffle(a) - перемешивает последовательность a
c = random.sample(a, b) - возвращает последовательность из b случайных уникальных элементов последовательности a
a.startswith(b) - проверяет является ли b началом строки a

"""
