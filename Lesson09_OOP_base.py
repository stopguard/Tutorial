""""""
# КЛАССЫ ОБЪЕКТЫ АТРИБУТЫ===============================================================================================
r"""
Класс - описание объекта, его атрибутов, функций, методов итд
Для объявления класса используется ключевая фраза:
    class <nameOfCamelCase>:

        auttrib1 = value
        
        def method1(self):
            ...body

self - ссылка на вызванный объект, экземпляр класса.

Объект - нечно описанное классом, его экземпляр.
для создания экземпляра класса требуется присвоить переменной название класса со скобками
a = set()

Атрибуты.
изменения атрибутов класса применяются напрямую к классу, атрибуты экземпляра можно менять внутри любого метода:
    class Auto:
 
        # атрибуты класса
        auto_count = 0
     
        # методы класса
        def on_auto_start(self, auto_name, auto_model, auto_year):
            print("Автомобиль заведен")
            self.auto_name = auto_name
            self.auto_model = auto_model
            self.auto_year = auto_year
            Auto.auto_count += 1
"""
# КОНСТРУКТОРЫ И МЕТОДЫ=================================================================================================
r"""
Конструктор - метод вызываемый при создании класса. Его необходимо оформить как метод __init__:
    class Auto:
        # атрибуты класса
        auto_count = 0
    
        # методы класса
        def __init__(self):
            Auto.auto_count += 1
            print(Auto.auto_count)

Метод - функция присущая конкретному классу, выполняемая при вызове в связи с объектом от которого вызывается:
    a = list()
    a.append(2)
append - это метод, a - объект от имени которого вызывается метод. внутри метода a прописывается как self
    так как при вызове передаётся в метод вместе с аргументами, 
    благодаря чему метод append может взаимодействовать с атрибутами объекта a
"""
# ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ==================================================================================================
r"""
Понятие области видимости распространяется и на классы. 
    Переменные объявленные внутри методов недоступны извне, так же как и внешние переменные для методов недоступны
    без передачи в метод в виде аргументов или через ключевые слова nonlocal или global
Атрибуты класса и экземпляров класса являются глобальными переменными в тех областях видимости где они объявлены.
"""
# МОДИФИКАТОРЫ ДОСТУПА==================================================================================================
r"""
Имеются 3 вида модификаторов доступа для определения областей видимости переменных и возможностей их изменения
    Public      - доступен для чтения и изменения. Записывается как обычно
    Protected   - доступен для чтения. Записывается с одним символом подчёркивания перед именем: _attr _method(self)
                  Значение может меняться лишь в пределах пакета в котором объявлен класс: __attr __method(self)
    Private     - доступен к только в пределах класса. 
                  Записывается с двумя подчёркиваниями перед именем.
"""
# ИНКАПСУЛЯЦИЯ==========================================================================================================
r"""
Инкапсуляция - механизм сокрытия данных.
В Python реализуется на уровне соглашения.
Одиночное подчёркивание перед именем метода/атрибута свидетельствует о том 
    что эти данные не предназначены для использования вне класса, но доступны по своему имени.
Двойное подчёркивание перед именем делает метод/атрибут недоступным по имени, 
    но использование возможно с добавлением перед именем метода/атрибута имени класса с подчёркиванием перед ним:
    class Auto:
        self.__auto_model = "CX9"
        
    a._Auto__auto_model
"""
# НАСЛЕДОВАНИЕ==========================================================================================================
r"""
Подразумевается наследование одним классом/объектом характеристик другого
        class Tr:
            def tr_meth(self):
                pass
        
        class Au(Tr):
            def au_meth(self):
                pass
    Tr - родительский класс, Au - дочерний
    
    для дочернего объекта доступны все атрибуты и методы родительского.
    чтобы работать с унаследованными атрибутами необходимо их перечислить с помощью ключевой фразы 
        super().__init__(color, param_1,...)
    Пример:
        class Shape:
            def __init__(self, color, param_1, param_2):
                self.color = color
                self.param_1 = param_1
                self.param_2 = param_2
        
        class Rectangle(Shape):
            def __init__(self, color, param_1, param_2, rectangle_p):
                super().__init__(color, param_1, param_2)
                self.rectangle_p = rectangle_p

    Для использования наследуемых методов это делать не нужно.
У одного родительского объекта может быть несколько дочерних и наоборот.
    в случае нескольких родителей при обращении к атрибутам и методам имеющимся у обоих родителей, 
    вызывается тот который имеется у первого в списке.
"""
# ПОЛИМОРФИЗМ===========================================================================================================
r"""
Многофункциональность. Проявляется в перегрузке и переопределении методов классов

Перегрузка методов 
    реализуется в возможности реализации разной логики выполнения метода в зависимости от количества и типа параметров
    
                            class Auto:
                                def auto_start(self, param_1, param_2=None):
                                    if param_2 is not None:
                                        print(param_1 + param_2)
                                    else:
                                        print(param_1)
                                        
Переопределение методов
    выражается в наличии методов с одинаковыми названия у родительских и дочерних классов, но с разной логикой.
    
                            class Transport:
                                def show_info(self):
                                    print("Родительский метод класса Transport")
                            
                            # класс Auto, наследующий Transport
                            class Auto(Transport):
                                def show_info(self):
                                    print("Родительский метод класса Auto")

"""
# ======================================================================================================================
r"""

"""


class Auto:
    def __init__(self):
        print("Автомобиль заведен")
        self.auto_name = "Mazda"
        self._auto_year = 2019
        self.__auto_model = "CX9"


a = Auto()
print('print(dir(Auto))', dir(Auto))
print('print(dir(a))', dir(a))
